import { readFile, writeFile } from "node:fs/promises";
import { fileURLToPath } from "node:url";
import { dirname, join } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const repoRoot = join(__dirname, "..", "..");
const tokensPath = join(repoRoot, "src", "design-system", "tokens", "tokens.json");
const cssOutPath = join(repoRoot, "src", "design-system", "tokens", "tokens.css");
const tsOutPath = join(repoRoot, "src", "design-system", "tokens", "index.ts");

const raw = await readFile(tokensPath, "utf8");
const tokens = JSON.parse(raw);

const flatten = (obj, path = []) => {
  const entries = [];
  for (const [key, value] of Object.entries(obj)) {
    const currentPath = [...path, key];
    if (value && typeof value === "object" && !Array.isArray(value)) {
      entries.push(...flatten(value, currentPath));
    } else {
      entries.push([currentPath, value]);
    }
  }
  return entries;
};

const getValueByPath = (path) => {
  return path.reduce((acc, key) => (acc ? acc[key] : undefined), tokens);
};

const resolveReferences = (value) => {
  if (typeof value !== "string") {
    return value;
  }
  return value.replace(/\{([^}]+)\}/g, (_, ref) => {
    const refPath = ref.trim().split(".");
    const resolved = getValueByPath(refPath);
    if (resolved === undefined) {
      throw new Error(`Unable to resolve token reference: ${ref}`);
    }
    return resolveReferences(resolved);
  });
};

const toCssVarName = (path) => `--ads-${path.join("-")}`;

const tokenEntries = flatten(tokens).map(([path, value]) => [path, resolveReferences(value)]);

const toCssLines = (entries) =>
  entries
    .map(([path, value]) => `  ${toCssVarName(path)}: ${value};`)
    .join("\n");

const getEntry = (key) => tokenEntries.filter(([path]) => path[0] === key);

const lightOverrides = [];
const darkOverrides = [
  [["color", "semantic", "text", "default"], "#e2e8f0"],
  [["color", "semantic", "text", "strong"], "#f8fafc"],
  [["color", "semantic", "text", "subtle"], "#cbd5f5"],
  [["color", "semantic", "text", "inverse"], "#020617"],
  [["color", "semantic", "background", "surface"], "#0f172a"],
  [["color", "semantic", "background", "muted"], "#111c33"],
  [["color", "semantic", "background", "raised"], "#152240"],
  [["color", "semantic", "background", "subtle"], "#1e2b4a"],
  [["color", "semantic", "background", "inverse"], "#f8fafc"],
  [["color", "semantic", "border", "subtle"], "rgba(15, 23, 42, 0.35)"],
  [["color", "semantic", "border", "strong"], "rgba(148, 163, 184, 0.45)"],
  [["color", "semantic", "border", "inverse"], "rgba(15, 23, 42, 0.65)"]
];

const applyOverrides = (entries, overrides) => {
  const map = new Map(entries.map(([path, value]) => [path.join("."), value]));
  for (const [path, value] of overrides) {
    map.set(path.join("."), value);
  }
  return Array.from(map.entries()).map(([key, value]) => [key.split("."), value]);
};

const baseCategories = [
  "color",
  "typography",
  "spacing",
  "radii",
  "shadows"
];

const baseEntries = tokenEntries.filter(([path]) => baseCategories.includes(path[0]));

const css = `/* Generated by build-tokens.mjs – do not edit by hand */\n:root {\n${toCssLines(applyOverrides(baseEntries, lightOverrides))}\n}\n\n[data-theme='dark'] {\n${toCssLines(applyOverrides(baseEntries, darkOverrides))}\n}\n`;

await writeFile(cssOutPath, css, "utf8");

const ts = `// Generated by build-tokens.mjs – do not edit by hand\nimport rawTokens from './tokens.json';\n\nexport const tokens = rawTokens as const;\nexport type AdsTokens = typeof tokens;\n`;

await writeFile(tsOutPath, ts, "utf8");

console.log(`Generated ${cssOutPath} and ${tsOutPath}`);