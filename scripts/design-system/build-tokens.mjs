import { readFile, writeFile } from "node:fs/promises";
import { fileURLToPath } from "node:url";
import { dirname, join } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const repoRoot = join(__dirname, "..", "..");
const tokensDir = join(repoRoot, "design-system", "tokens");
const tokensPath = join(tokensDir, "tokens.json");
const cssOutPath = join(tokensDir, "tokens.css");
const tsOutPath = join(tokensDir, "index.ts");

const raw = await readFile(tokensPath, "utf8");
const tokens = JSON.parse(raw);

const { modes = {}, meta: _meta, ...foundations } = tokens;

const deepClone = (value) => JSON.parse(JSON.stringify(value));

const flatten = (obj, path = []) => {
  const entries = [];
  for (const [key, value] of Object.entries(obj)) {
    const currentPath = [...path, key];
    if (value && typeof value === "object" && !Array.isArray(value)) {
      entries.push(...flatten(value, currentPath));
    } else {
      entries.push([currentPath, value]);
    }
  }
  return entries;
};

const getValueByPath = (obj, path) => path.reduce((acc, key) => (acc ? acc[key] : undefined), obj);

const resolveReferences = (value, tree, seen = new Set()) => {
  if (typeof value !== "string") {
    return value;
  }

  return value.replace(/\{([^}]+)\}/g, (_, ref) => {
    const refPath = ref.trim().split(".");
    const refKey = refPath.join(".");
    if (seen.has(refKey)) {
      throw new Error(`Circular token reference detected: ${refKey}`);
    }
    const resolved = getValueByPath(tree, refPath);
    if (resolved === undefined) {
      throw new Error(`Unable to resolve token reference: ${ref}`);
    }
    const nextSeen = new Set(seen);
    nextSeen.add(refKey);
    return resolveReferences(resolved, tree, nextSeen);
  });
};

const resolveEntries = (tree) => {
  const entries = flatten(tree);
  return entries.map(([path, value]) => [path, resolveReferences(value, tree)]);
};

const toCssVarName = (path) => `--ads-${path.join("-")}`;

const toCssLines = (entries) =>
  entries
    .map(([path, value]) => `  ${toCssVarName(path)}: ${value};`)
    .join("\n");

const deepMerge = (target, source) => {
  if (!source || typeof source !== "object" || Array.isArray(source)) {
    return target;
  }

  for (const [key, value] of Object.entries(source)) {
    if (value && typeof value === "object" && !Array.isArray(value)) {
      const nextTarget =
        target[key] && typeof target[key] === "object" && !Array.isArray(target[key])
          ? target[key]
          : {};
      target[key] = deepMerge(nextTarget, value);
    } else {
      target[key] = value;
    }
  }

  return target;
};

const buildModeEntries = (overrideTree = {}) => {
  const merged = deepClone(foundations);
  deepMerge(merged, overrideTree);
  return resolveEntries(merged);
};

const lightOverrides = modes.light && Object.keys(modes.light).length > 0 ? modes.light : undefined;
const baseEntries = buildModeEntries(lightOverrides);

const cssBlocks = [`:root,\n[data-theme='light'] {\n${toCssLines(baseEntries)}\n}`];

for (const [modeName, override] of Object.entries(modes)) {
  if (modeName === "light") continue;
  const modeEntries = buildModeEntries(override);
  cssBlocks.push(`[data-theme='${modeName}'] {\n${toCssLines(modeEntries)}\n}`);
}

const css = `/* Generated by build-tokens.mjs – do not edit by hand */\n@layer tokens {\n${cssBlocks.join("\n\n")}\n}\n`;

await writeFile(cssOutPath, css, "utf8");

const ts = `// Generated by build-tokens.mjs – do not edit by hand\nimport rawTokens from './tokens.json';\n\nexport const tokens = rawTokens as Readonly<typeof rawTokens>;\nexport type AdsTokens = typeof tokens;\n`;

await writeFile(tsOutPath, ts, "utf8");

console.log(`Generated ${cssOutPath} and ${tsOutPath}`);